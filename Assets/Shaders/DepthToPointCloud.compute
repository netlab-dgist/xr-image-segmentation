// Compute Shader for extracting PointCloud from Depth + YOLO Mask
// Simplified version: Reverted to Simple Sampling to fix missing center issue

#pragma kernel ExtractPointCloud
#pragma kernel DebugMask

// Input Textures - Depth is Texture2DArray (stereo)
Texture2DArray<float> _DepthTexture;
SamplerState sampler_DepthTexture;

// Input Buffers
StructuredBuffer<float> _MaskBuffer;      // 160x160 flat array (YOLO mask weights)
StructuredBuffer<uint> _RGBBuffer;        // RGB packed as uint (RGBA32)

// Output Buffers
RWStructuredBuffer<float4> _PositionBuffer;  // xyz, w=1 (valid)
RWStructuredBuffer<uint> _ColorBuffer;       // RGBA packed
RWStructuredBuffer<int> _CounterBuffer;      // [0]=pointCount, [1]=maskPassCount, [2]=uvFailCount, [3]=minDepthFail, [4]=maxDepthFail

// Uniforms - Camera Intrinsics & Pose (RGB Camera)
float4 _CameraIntrinsics;     // fx, fy, cx, cy (in RGB resolution pixels)
float4 _CameraPosition;       // Camera world position
float4x4 _CameraRotation;     // Camera rotation matrix (world space)

// BBox parameters (YOLO 640 centered space)
float4 _BBoxParams;           // centerX, centerY, width, height

// Other parameters
float _ConfidenceThreshold;
int _RGBWidth;
int _RGBHeight;
int _DepthWidth;
int _DepthHeight;
int _MaxPoints;
float _MinDepth;
float _MaxDepth;

// Depth conversion params (from Meta SDK)
float4 _DepthZBufferParams;   // x=invDepthFactor, y=depthOffset

// Depth reprojection matrix (Not used in simple mode, but kept for compatibility)
float4x4 _DepthReprojMatrix;

// Helper: Convert mask coordinate to RGB pixel coordinate using Normalized UV
int2 MaskToRGBPixel(float maskX, float maskY, float4 bbox, int rgbW, int rgbH)
{
    // 1. Mask UV (0~1)
    float u = maskX / 160.0;
    float v = maskY / 160.0; // 0:Bottom, 1:Top from ComputeShader ID

    // 2. Map to Global Texture UV
    // bbox values are in YOLO pixel space centered at 0 (-320 ~ 320)
    // X: Left(-320) ~ Right(320). U: 0~1
    // Y: Top(-320) ~ Bottom(320). V: 1~0 (Unity Texture V is Bottom-Up)

    // Calculate Normalized BBox params (0.0 ~ 1.0 scale relative to image size)
    float bboxCenterX_Norm = bbox.x / 640.0; // -0.5 ~ 0.5
    float bboxCenterY_Norm = bbox.y / 640.0; // -0.5 ~ 0.5 (YOLO Y: Down is positive)
    float bboxW_Norm = bbox.z / 640.0;
    float bboxH_Norm = bbox.w / 640.0;

    // Calculate Texture U (Left to Right)
    // Center - HalfWidth + u * Width
    float texU = 0.5 + bboxCenterX_Norm - bboxW_Norm * 0.5 + u * bboxW_Norm;

    // Calculate Texture V (Bottom to Top)
    // Unity V is opposite to YOLO Y.
    // YOLO Top(-0.5) maps to Unity Top(1.0)
    // YOLO Bottom(0.5) maps to Unity Bottom(0.0)
    // CenterY(YOLO) maps to 0.5 - CenterY(YOLO)
    
    // TexV Start (Mask Bottom v=0) -> YOLO Box Bottom -> Unity Low V
    // TexV End (Mask Top v=1) -> YOLO Box Top -> Unity High V
    
    // Box Bottom in Unity V = 0.5 - (bboxCenterY + bboxH/2)
    // Box Top in Unity V = 0.5 - (bboxCenterY - bboxH/2)
    // Interpolate using v (0->1)
    
    float boxBottomV = 0.5 - (bboxCenterY_Norm + bboxH_Norm * 0.5);
    float boxTopV = 0.5 - (bboxCenterY_Norm - bboxH_Norm * 0.5);
    
    float texV = boxBottomV + v * (boxTopV - boxBottomV);

    // [보정] Manual Y-axis offset: Shift UP by 10%
    texV += 0.1;

    int pixelX = (int)(texU * (float)rgbW);
    int pixelY = (int)(texV * (float)rgbH);

    return int2(clamp(pixelX, 0, rgbW - 1), clamp(pixelY, 0, rgbH - 1));
}

// Simple Depth Sampling (1:1 UV mapping)
// Assumes RGB and Depth cameras have similar FOV and alignment
float SampleDepthSimple(int2 rgbPixel, int rgbW, int rgbH)
{
    // Map RGB pixel directly to Depth UV
    float u = (float)rgbPixel.x / (float)rgbW;
    float v = (float)rgbPixel.y / (float)rgbH;

    int dx = (int)(u * (float)(_DepthWidth - 1));
    int dy = (int)(v * (float)(_DepthHeight - 1));

    dx = clamp(dx, 0, _DepthWidth - 1);
    dy = clamp(dy, 0, _DepthHeight - 1);

    // Sample from slice 0 (left eye)
    float rawDepth = _DepthTexture[int3(dx, dy, 0)];

    // Convert to linear depth
    float depthNdc = rawDepth * 2.0 - 1.0;
    float linearDepth = _DepthZBufferParams.x / (depthNdc + _DepthZBufferParams.y);

    return linearDepth;
}

// Hole Filling Depth Sampling
// If center depth is invalid, search 3x3 neighborhood for a valid depth
float SampleDepthFilled(int2 rgbPixel, int rgbW, int rgbH)
{
    // 1. Center sample
    float d = SampleDepthSimple(rgbPixel, rgbW, rgbH);
    if (d >= _MinDepth && d <= _MaxDepth) return d;

    // 2. Neighbor search (Spiral or simple grid)
    // 3x3 search (radius 1)
    const int radius = 2; 
    float sumDepth = 0.0;
    float validCount = 0.0;

    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            if (x == 0 && y == 0) continue;

            int2 neighbor = rgbPixel + int2(x, y);
            float nd = SampleDepthSimple(neighbor, rgbW, rgbH);
            
            if (nd >= _MinDepth && nd <= _MaxDepth)
            {
                sumDepth += nd;
                validCount += 1.0;
            }
        }
    }

    if (validCount > 0.0)
    {
        return sumDepth / validCount; // Average of valid neighbors
    }

    return -1.0; // Failed to fill
}

[numthreads(8, 8, 1)]
void ExtractPointCloud(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= 160 || id.y >= 160) return;

    // Row-major indexing (matching C# data layout)
    int flippedY = 159 - (int)id.y;
    int maskIdx = flippedY * 160 + (int)id.x;
    float maskVal = _MaskBuffer[maskIdx];

    if (maskVal < _ConfidenceThreshold)
        return;

    InterlockedAdd(_CounterBuffer[1], 1);

    int2 rgbPixel = MaskToRGBPixel((float)id.x, (float)id.y, _BBoxParams, _RGBWidth, _RGBHeight);

    // [수정] Hole Filling 적용
    float depthMeters = SampleDepthFilled(rgbPixel, _RGBWidth, _RGBHeight);

    // [보정] Depth Offset: 포인트가 너무 앞에 나오므로 뒤로 0.1m 밈
    depthMeters += 0.1;

    if (depthMeters < _MinDepth)
    {
        InterlockedAdd(_CounterBuffer[3], 1);
        return;
    }
    if (depthMeters > _MaxDepth)
    {
        InterlockedAdd(_CounterBuffer[4], 1);
        return;
    }

    // Compute World Position
    float fx = _CameraIntrinsics.x;
    float fy = _CameraIntrinsics.y;
    float cx = _CameraIntrinsics.z;
    float cy = _CameraIntrinsics.w;

    float3 dirInCamera = float3(
        ((float)rgbPixel.x - cx) / fx,
        ((float)rgbPixel.y - cy) / fy,
        1.0
    );
    dirInCamera = normalize(dirInCamera);
    float3 dirInWorld = mul((float3x3)_CameraRotation, dirInCamera);

    float3 worldPos = _CameraPosition.xyz + dirInWorld * depthMeters;

    int idx;
    InterlockedAdd(_CounterBuffer[0], 1, idx);
    if (idx >= _MaxPoints) return;

    _PositionBuffer[idx] = float4(worldPos, 1.0);

    // [수정] 디버그 색상 제거하고 원래 RGB 색상 사용
    int rgbIdx = rgbPixel.y * _RGBWidth + rgbPixel.x;
    if (rgbIdx >= 0 && rgbIdx < _RGBWidth * _RGBHeight)
    {
        _ColorBuffer[idx] = _RGBBuffer[rgbIdx];
    }
    else
    {
        _ColorBuffer[idx] = 0xFFFFFFFF;
    }
}

[numthreads(8, 8, 1)]
void DebugMask(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= 160 || id.y >= 160) return;

    int flippedY = 159 - (int)id.y;
    int maskIdx = flippedY * 160 + (int)id.x;
    float maskVal = _MaskBuffer[maskIdx];

    if (maskVal > _ConfidenceThreshold)
    {
        InterlockedAdd(_CounterBuffer[1], 1);

        int2 rgbPixel = MaskToRGBPixel((float)id.x, (float)id.y, _BBoxParams, _RGBWidth, _RGBHeight);
        float depthMeters = SampleDepthSimple(rgbPixel, _RGBWidth, _RGBHeight);

        // [수정] 디버그 마스크에서도 필터링 대신 카운팅만 수행 (모두 유효한 것으로 처리)
        if (depthMeters < _MinDepth)
        {
            InterlockedAdd(_CounterBuffer[3], 1);
        }
        else if (depthMeters > _MaxDepth)
        {
            InterlockedAdd(_CounterBuffer[4], 1);
        }
        
        // 무조건 포인트 생성 카운트 증가
        InterlockedAdd(_CounterBuffer[0], 1);
    }
}
